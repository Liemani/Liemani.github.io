[홈으로](/)
# 반복하며 작업하는 코드의 작성
October 10, 2021


## Index

1. 작업에 순서가 존재하는 반복 코드
2. 조건에 따라 특정 작업을 하는 반복 코드
3. 조건에 따라 가변적 횟수 동안 특정 작업을 하는 반복 코드


## 작업에 순서가 존재하는 반복 코드

한 문자열을 다른 문자열 뒤에 복사해 붙이는 코드가 필요하다고 하자.
이를 라이브러리 함수 없이 구현한다면 아래와 같을 것이다.
(이 때, 문제에 집중하기 위해 `target_str` 은 문자열 `source_str` 을 뒤에 붙이기(append) 에 충분한 메모리 공간을 할당받았다고 하자)

```c
void	append_str(const char *target_str, const char *source_str)
{
	while (*target_str != '\0')
		++source_str;
	while ((*target_str++ = *source_str++) != '\0')
		;
}
```

위의 구현에서는 while 문을 2 번 사용했지만, 사실 전체적으로 보면 `target_str` 을 끝날 때까지 반복하고 있다.
하지만 이 경우는 작업의 순서가 정해져 있기 때문에 굳이 반복문 한 번으로 코드를 복잡하게 만들 필요 없이, 반복문을 2 번 사용하는 것으로 쉽게 구현이 가능하다.
더 생각해볼 만한 부분이 있다면, '가독성을 높이기 위해 두 번째 while 문을 조금 더 길게 쓸 것인가' 와 '마지막 null character('\0') 는 어디서 복사되는가?' 일 것이다.
위의 방법은 while 의 `조건문`에서 값을 복사하기 때문에 마지막에 '\0' 를 복사한 후 조건문을 검사한다. 그래서 추가적으로 '\0' 를 마지막에 넣어 줄 필요가 없다. 그런데 만약 2 번째 while 문을 다음과 같이 작성한다면,

```c
	while ((*target_str++ = *source_str++) != '\0')
		;

	->

	while (*source_str != '\0')
		*target_str++ = *source_str++;
	*target_str = '\0';
```

값 복사를 while 문의 `조건문(condition)` 위치가 아닌 `몸통(body)`에서 진행하기 때문에, `source_str` 의 마지막 '\0' 는 복사되지 않고 while 문을 빠져나오게 된다. 그래서 `target_str` 의 마지막 '\0' 는 직접 넣어 주어야 한다.


## 조건에 따라 특정 작업을 하는 반복 코드

이번엔 조금 더 들어가 본다.
반복되는 와중에 처리 방식이 그때 그때 달라질 수 있는 코드를 보자.
예를 들어, `source_str` 을 `target_str` 에 복사하는데, 만약 문자가 소문자면 대문자로 바꿔준다고 하자.
그럼 아래와 같이 어렵지 않게 구현될 것이다.

```c
int	is_lowercase(char ch)
{
	return ('a' <= ch && ch <= 'z');
}

void	strcpy_lower_to_upper(const char *target_str, const char *source_str)
{
	while (*source_str != '\0')
	{
		if (is_lowercase(*source_str))
			*target_str++ = 'A' + (*source_str++ - 'a');
		else
			*target_str++ = *source_str++;
	}
	*target_str = '\0';
}
```

위의 while 문은 문자열 `source_str` 을 처음부터 끝까지 순차적으로 접근할 것이다.
그리고 매 상황(대문자인지 소문자인지) 에 따라 첫 번째 동작 이나 두 번째 동작을 수행한다.
이 때 각 문자는 직접 `*source_str` 값을 읽기 전까지는, 이전까지의 상황만으로 대문자일지 소문자일지 알 수 없다.
때문에 한 while 문 안에서, 상황에 따라 원하는 동작을 수행하도록 코드를 작성할 수밖에 없다.


## 조건에 따라 가변적 횟수 동안 특정 작업을 하는 반복 코드

이번 예시 역시 두 문자열 `source_str` 과 `target_str` 이 있다.
`source_str` 을 한 글자씩 반복하면서, 만약 문자가 알파벳이었다면 알파벳이 아닐 때까지 문자를 `target_str` 으로 복사해온다.
그리고 복사해온 단어 사이에는 space character 를 하나 추가한다.
그런데 여기서 한 가지 추가 사항이 있다.
알파벳 단어를 복사해오는 기능은 따로 분리하여 함수로 만들어야 한다.

```c
int	is_alpha(char ch)
{
	return (('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z'));
}

void	cpy_all_word(const char *target_str, const char *source_str)
{
	while (*source_str != '\0')
		if (is_alpha(*source_str))
		{
			while (is_alpha(*source_str))
				*target_str++ = *source_str++;
			*target_str++ = ' ';
		}
	*(target_str - 1) = '\0';
}
```
> 제일 안쪽의 while 은 do while 을 사용하는게 더 효율적일 수 있겠지만 그 부분은 넘어가기로 하겠다.

완성된 코드를 보면 주구장창 설명했던 것에 비해 꽤나 간소하게 느껴진다.
2 중 while 문을 사용하여 구현하니 나도 놀랄 정도로 짧은 코드가 나왔다.
그런데 내가 오늘 말하고자 했던 핵심은 사실 바로 이 다음이다.
여기서 만약 안쪽의 while 부분을 따로 떼서 `함수로` 구현하고 싶다면 어떻게 될까?
문자열에서 알파벳이 아닌 문자가 나올 때까지, 연달은 알파벳을 다른 문자열로 복사하는 기능은 함수로 구현해 놓는다면 어쩌면 다른 곳에서 또 쓰일지도 모른다.
그래서 한 단어만 복사하는 함수를 따로 작성해놓고, 우리의`cpy_all_word()` 가 그 함수를 호출해서 사용하는 것은 좋은 생각인 것 같다.
일단 제대로 작동하지 않더라도 무작정 함수로 떼어 놓고 생각해보자.

```c
int	is_alpha(char ch)
{
	return (('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z'));
}

void	cpy_a_word(const char *target_str, const char *source_str)
{
	while (is_alpha(*source_str))
		*target_str++ = *source_str++;
}

void	cpy_all_word(const char *target_str, const char *source_str)
{
	while (*source_str != '\0')
		if (is_alpha(*source_str))
		{
			cpy_a_word(target_str, source_str);
			*target_str++ = ' ';
		}
	*(target_str - 1) = '\0';
}
```

이렇게 한 단어를 복사하는 함수를 분리해보면 `target_str` 과 `source_str` 이 `cpy_a_word()` 로부터 `cpy_all_word()` 로 전달되지 않는 문제가 발생한다.
그래서 `cpy_a_word()` 가 수행되면서 전진한 문자열들의 주소가 호출한 함수(caller) 에게 전달되지 않아, `cpy_a_word()` 를 호출할 당시의 `target_str` 과 `source_str` 을 사용하게 된다.
이 문제를 의도에 맞게 수정하기 위해서 나는 아래와 같은 5 가지 방법을 생각해보았다.

1. 호출한 함수(caller) 가 바뀐 값을 직접 다시 계산하여 바꾸기.
2. 모듈로 떼어낸 함수(callee) 가 어디까지 작업했는지 알려주는 인덱스 또는 주소를 반환하기.
3. 작업 위치를 기억하는 변수의 주소를 인자로 전달하기.
4. caller 나 또는 caller 를 호출하는 함수에 작업 위치를 저장하는 변수를 멤버로 갖는 구조체(structure) 를 두고, 이 structure 를 전달하기.
5.  특수한 작업을 하는 중인지를 flag 에 기록해두고, 매 반복(loop) 마다 체크하여 필요한 routine 실행하도록 하기. 이 경우 떼어낸 모듈은 한 단어를 모두 복사하기 보다는 한 문자를 복사하는 함수가 될 것이다.

## \>\> 다 음 에    이 어 서 \<\<


## 다음 포스트에 사용할 내용

1. 어디까지 작업했는지 인덱스 및 주소를 반환하기.
        - 이것이 편한 경우가 있다. inner function 이 재사용되지 않는 경우이다. 그리>고 어떤 위치에서 정확히 발생하거나 발생하지 않는 경우 유용할 것 같다.
2. 작업 위치를 기억하는 변수의 주소를 인자로 전달하기. 
        - 이 방법은 너무 별로다. 만약 iterate 하는 대상이 주소라면 이중 포인터를 사>용해야 해서 가독성도 떨어진다.
3. 상위에 object 를 둬서 현재 작업 위치를 기억하도록 하고, 이 object 를 전달하여 사용하기 
        - 이 방법은 가독성은 좋으나 모듈화되지 않는다는 점이 불편하다. object 가 inner function 까지 전달되기 때문에, inner function 에서는 사용하지 않는 object 의 다른 멤버 변수에 접근하는 등, 모듈화하기에 좋지 않다. 그리고 inner function 이 object 에 의존적이어지는 문제도 있다. 
4.  특수한 작업을 하는 중인지를 flag 에 기록해두고 매 loop 마다 체크하여 필요한 routine 실행하도록 하기.
        - 매 loop 마다 어떤 상태인지 flag 를 확인해야하는 overhead 가 존재한다. 하지만 코드가 명확해지고 모듈화에 유리하다는 장점이 있다.
