[홈으로](/)
# 반복하며 작업하는 코드의 작성
October 10, 2021

## Index

1. 작업에 순서가 존재하는 반복 코드
2. 조건에 따라 특정 작업을 하는 반복 코드
3. 조건에 따라 가변적 횟수 동안 특정 작업을 하는 반복 코드

## 작업에 순서가 존재하는 반복 코드

한 문자열을 다른 문자열 뒤에 복사해 붙이는 코드가 필요하다고 하자. 이를 라이브러리 함수 없이 구현한다면 아래와 같을 것이다. (이 때, 문제에 집중하기 위해 `target_str` 은 `source_str` 의 문자열을 뒤에 붙이기(append) 에 충분한 메모리 공간을 할당받았다고 하자.)

```c
void	append_str(char *source_str, char *target_str)
{
	while (*target_str != '\0')
		++source_str;
	while ((*target_str++ = *source_str++) != '\0')
		;
}
```

이 경우는 작업의 순서가 정해져 있기 때문에 반복문 2 번을 사용하는 방식으로 쉽게 구현이 가능하다.
생각해볼 만한 부분이 있다면 '가독성을 위해 두 번째 while 문을 조금 더 길게 쓸 것인가' 와 '마지막 null character('\0') 까지 다 복사하도록 하는 방법' 일 것이다.
위의 방법은 while 문의 조건문에서 값을 복사하기 때문에 마지막에 '\0' 를 복사한 후 조건을 검사하여, 추가적으로 '\0' 를 마지막에 넣어주는 작업이 필요 없지만, 2 번째 while 문을 다음과 같이 작성한다면

```c
	while ((*target_str++ = *source_str++) != '\0')
		;

	->

	while (*source_str != '\0)
		*target_str++ = *source_str++;
	*target_str = '\0';
```

값 복사를 while 문의 조건문 위치가 아닌 몸통에서 진행하기 때문에, `source_str` 의마지막 '\0' 은 복사되지 않고 while 문을 빠져나오게 된다. 따라서 `target_str` 에 마지막 '\0' 을 넣어주는 작업을 추가로 해주어야 한다.

## 조건에 따라 특정 작업을 하는 반복 코드

이번엔 조금 더 들어가 반복되는 와중에 처리 방식이 그때 그때 달라질 수 있는 코드를 보자.
예를 들어, `source_str` 을 `target_str` 에 복사하는데, 만약 문자가 소문자면 대문자로 바꿔준다고 하자.
그럼 아래와 같이 어렵지 않게 구현될 것이다.

```c
int	is_lowercase(char ch)
{
	return ('a' <= ch && ch <= 'z');
}

void	strcpy_lower_to_upper(char *source_str, char *target_str)
{
	while (*source_str != '\0')
	{
		if (is_lowercase(*source_str))
			*target_str++ = 'A' + (*source_str++ - 'a');
		else
			*target_str++ = *source_str++;
	}
	*target_str = '\0';
}
```

`source_str` 을 처음부터 끝까지 순차적으로 체크하면서 매번 상황(대문자인지 소문자인지) 에 따라 첫 번째 동작을 수행하거나 두 번째 동작을 수행한다. 이 경우 매번 직접 그 문자를 확인하기 전까지는 대문자일지 소문자일지 정해져있지 않다. 때문에 while 문 하나를 두고 안에서 상황에 따라 원하는 동작을 수행하도록 코드를 작성할 수밖에 없다.

## 조건에 따라 가변적 횟수 동안 특정 작업을 하는 반복 코드

오늘의 메인 주제이다.
작성중..

반복을 처리하는 코드를 작성 하다보면, 범위나 상황에 따라 다르게 작동하도록 해야 하는 경우가 많다. 이런 코드를 짜는 방법을 크게 4 가지로 구분해 보았다.

1. 어디까지 작업했는지 인덱스 및 주소를 반환하기.
        - 이것이 편한 경우가 있다. inner function 이 재사용되지 않는 경우이다. 그리>고 어떤 위치에서 정확히 발생하거나 발생하지 않는 경우 유용할 것 같다.
2. 작업 위치를 기억하는 변수의 주소를 인자로 전달하기. 
        - 이 방법은 너무 별로다. 만약 iterate 하는 대상이 주소라면 이중 포인터를 사>용해야 해서 가독성도 떨어진다.
3. 상위에 object 를 둬서 현재 작업 위치를 기억하도록 하고, 이 object 를 전달하여 사용하기 
        - 이 방법은 가독성은 좋으나 모듈화되지 않는다는 점이 불편하다. object 가 inner function 까지 전달되기 때문에, inner function 에서는 사용하지 않는 object 의 다른 멤버 변수에 접근하는 등, 모듈화하기에 좋지 않다. 그리고 inner function 이 object 에 의존적이어지는 문제도 있다. 
4.  특수한 작업을 하는 중인지를 flag 에 기록해두고 매 loop 마다 체크하여 필요한 routine 실행하도록 하기.
        - 매 loop 마다 어떤 상태인지 flag 를 확인해야하는 overhead 가 존재한다. 하지만 코드가 명확해지고 모듈화에 유리하다는 장점이 있다.
